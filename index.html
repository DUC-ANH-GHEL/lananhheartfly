<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Thi·ªáp m·ªùi sinh nh·∫≠t Lan Anh</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@300;400;600;700;800&display=swap" rel="stylesheet">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    overflow: hidden;
    background: #000;
    font-family: "Poppins", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  /* Hide the existing experience until the card is opened */
  body:not(.experience-on) canvas,
  body:not(.experience-on) #text {
    opacity: 0;
    pointer-events: none;
  }

  canvas,
  #text {
    transition: opacity 600ms ease;
  }

  /* Birthday card overlay */
  .card-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(1400px 900px at 50% 35%, rgba(255, 120, 190, 0.18), rgba(0, 0, 0, 0.92));
    backdrop-filter: blur(5px) saturate(120%);
    -webkit-tap-highlight-color: transparent;
    isolation: isolate;
  }

  .card-overlay::before {
    content: "";
    position: absolute;
    inset: -30%;
    background:
      conic-gradient(from 180deg at 50% 50%,
        rgba(255, 110, 200, 0.00) 0deg,
        rgba(255, 110, 200, 0.20) 70deg,
        rgba(140, 120, 255, 0.18) 140deg,
        rgba(110, 220, 255, 0.12) 210deg,
        rgba(255, 200, 120, 0.10) 280deg,
        rgba(255, 110, 200, 0.00) 360deg);
    filter: blur(55px);
    opacity: 0.65;
    animation: aurora-rotate 18s linear infinite;
    z-index: -2;
  }

  .card-overlay::after {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(900px 520px at 15% 75%, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0) 60%),
      radial-gradient(700px 420px at 85% 25%, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0) 55%),
      radial-gradient(2px 2px at 15% 25%, rgba(255,255,255,0.22) 48%, rgba(255,255,255,0) 52%) 0 0 / 120px 120px,
      radial-gradient(2px 2px at 70% 65%, rgba(255,255,255,0.18) 48%, rgba(255,255,255,0) 52%) 0 0 / 170px 170px,
      radial-gradient(1px 1px at 35% 55%, rgba(255,255,255,0.15) 48%, rgba(255,255,255,0) 52%) 0 0 / 220px 220px;
    opacity: 0.55;
    mix-blend-mode: screen;
    animation: twinkle-drift 9s ease-in-out infinite;
    z-index: -1;
    pointer-events: none;
  }

  .card-overlay.hide {
    opacity: 0;
    pointer-events: none;
    transition: opacity 550ms ease;
  }

  .card {
    width: min(92vw, 740px);
    height: min(72vh, 420px);
    position: relative;
    perspective: 1200px;
    transform: translateZ(0);
  }

  .card-base {
    position: absolute;
    inset: 0;
    border-radius: 22px;
    overflow: hidden;
    background:
      linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.08)),
      radial-gradient(900px 560px at 70% 30%, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0)),
      linear-gradient(135deg, rgba(255, 160, 210, 0.16), rgba(155, 120, 255, 0.14));
    border: 1px solid rgba(255, 255, 255, 0.18);
    box-shadow:
      0 18px 50px rgba(0, 0, 0, 0.65),
      inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    transition: opacity 700ms ease;
  }

  /* Avoid text/graphics showing through the closed cover */
  .card-overlay:not(.open) .card-base {
    opacity: 0;
  }

  .card-overlay.open .card-base {
    opacity: 1;
    transition-delay: 650ms;
  }

  .card-base::after {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    width: 2px;
    transform: translateX(-1px);
    background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35), rgba(0,0,0,0.0));
    opacity: 0.35;
    pointer-events: none;
  }

  .card-base::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(600px 260px at 25% 25%, rgba(255, 160, 200, 0.18), rgba(255, 160, 200, 0)),
      radial-gradient(700px 320px at 80% 70%, rgba(170, 130, 255, 0.18), rgba(170, 130, 255, 0));
    pointer-events: none;
  }

  .card-base-content {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    padding: 22px;
    text-align: center;
    color: rgba(255, 255, 255, 0.92);
    transition: opacity 650ms ease, transform 650ms ease;
  }

  .card-overlay:not(.open) .card-base-content {
    opacity: 0;
    transform: translateY(10px);
  }

  .card-overlay.open .card-base-content {
    opacity: 1;
    transform: translateY(0);
    transition-delay: 700ms;
  }

  .card-inside {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0;
    align-items: center;
  }

  .inside-left,
  .inside-right {
    height: 100%;
    display: grid;
    place-items: center;
    padding: 22px;
  }

  .inside-left {
    color: rgba(255,255,255,0.92);
  }

  .inside-right {
    color: rgba(255,255,255,0.92);
  }

  .card-base-title {
    font-size: clamp(18px, 3.6vw, 22px);
    letter-spacing: 0.6px;
    opacity: 0.9;
  }

  .card-base-sub {
    margin-top: 10px;
    font-size: clamp(12px, 2.8vw, 14px);
    opacity: 0.75;
  }

  .card-cover {
    position: absolute;
    inset: 0;
    border-radius: 22px;
    transform-style: preserve-3d;
    transform-origin: left center;
    transition: transform 2600ms cubic-bezier(0.16, 1, 0.18, 1);
    box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
  }

  .card-cover-face {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    border-radius: 22px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.22);
    background:
      linear-gradient(180deg, rgba(20,10,30,0.28), rgba(20,10,30,0.10)),
      radial-gradient(920px 560px at 25% 20%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0) 62%),
      radial-gradient(700px 420px at 82% 78%, rgba(255, 170, 220, 0.16), rgba(255, 170, 220, 0) 58%),
      linear-gradient(135deg, rgba(255, 140, 210, 0.62), rgba(120, 90, 255, 0.38));
    box-shadow:
      inset 0 0 0 1px rgba(255, 255, 255, 0.08),
      inset 0 -40px 120px rgba(0,0,0,0.22);
  }

  .card-cover-face::before {
    content: "";
    position: absolute;
    inset: -40px;
    background:
      radial-gradient(3px 3px at 20% 30%, rgba(255,255,255,0.26) 45%, rgba(255,255,255,0) 48%) 0 0 / 30px 30px,
      radial-gradient(2px 2px at 70% 60%, rgba(255,255,255,0.18) 45%, rgba(255,255,255,0) 48%) 0 0 / 44px 44px,
      linear-gradient(120deg, rgba(255,255,255,0.0), rgba(255,255,255,0.12), rgba(255,255,255,0.0));
    opacity: 0.7;
    transform: translateX(-20%);
    animation: shimmer-sweep 4.8s ease-in-out infinite;
    pointer-events: none;
  }

  .card-cover-face::after {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(900px 520px at 50% 0%, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0) 65%),
      radial-gradient(2px 2px at 12% 18%, rgba(255,255,255,0.26) 45%, rgba(255,255,255,0) 48%) 0 0 / 160px 160px,
      radial-gradient(2px 2px at 80% 58%, rgba(255,255,255,0.22) 45%, rgba(255,255,255,0) 48%) 0 0 / 220px 220px;
    mix-blend-mode: screen;
    opacity: 0.6;
    pointer-events: none;
  }

  .card-cover-front {
    display: grid;
    place-items: center;
    padding: 22px;
    text-align: center;
  }

  .cover-content {
    width: min(520px, 92%);
    padding: 22px 20px;
    border-radius: 18px;
    background: linear-gradient(180deg, rgba(20,10,30,0.28), rgba(20,10,30,0.10));
    border: 1px solid rgba(255,255,255,0.16);
    box-shadow:
      0 18px 44px rgba(0,0,0,0.32),
      inset 0 0 0 1px rgba(255,255,255,0.06);
    backdrop-filter: blur(10px) saturate(125%);
  }

  .cover-content .invite-title {
    line-height: 1.15;
  }

  .cover-content .invite-name {
    line-height: 1.05;
  }

  .cover-badge {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.20);
    background: rgba(0,0,0,0.16);
    box-shadow:
      0 14px 34px rgba(0,0,0,0.28),
      inset 0 0 0 1px rgba(255,255,255,0.06);
    backdrop-filter: blur(10px);
  }

  .badge-dot {
    width: 9px;
    height: 9px;
    border-radius: 999px;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.0)),
                linear-gradient(135deg, rgba(255,150,205,0.9), rgba(140,120,255,0.9));
    box-shadow: 0 0 18px rgba(255,140,210,0.35);
  }

  .invite-title {
    font-size: clamp(18px, 4.2vw, 26px);
    font-weight: 700;
    letter-spacing: 1px;
    color: rgba(255, 255, 255, 0.95);
    text-shadow: 0 10px 30px rgba(0,0,0,0.45);
  }

  .invite-name {
    margin-top: 10px;
    font-family: "Great Vibes", cursive;
    font-size: clamp(38px, 8vw, 74px);
    font-weight: 400;
    letter-spacing: 0.5px;
    background: linear-gradient(90deg, rgba(255,240,248,0.98), rgba(255,180,222,0.96), rgba(200,190,255,0.96));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow:
      0 0 14px rgba(255, 130, 190, 0.55),
      0 0 34px rgba(160, 120, 255, 0.35);
  }

  .invite-hint {
    margin-top: 14px;
    font-size: clamp(12px, 3.2vw, 14px);
    opacity: 0.86;
  }

  .invite-hint strong {
    font-weight: 700;
    color: rgba(255,255,255,0.95);
  }

  .invite-hint kbd {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.95em;
    padding: 2px 6px;
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.22);
    background: rgba(0, 0, 0, 0.22);
  }

  .card-overlay.open .card-cover {
    transform: rotateY(-175deg);
  }

  .card-overlay:focus {
    outline: none;
  }

  .card-overlay[tabindex="0"] {
    cursor: pointer;
  }

  @keyframes aurora-rotate {
    0% { transform: rotate(0deg) scale(1.02); }
    100% { transform: rotate(360deg) scale(1.02); }
  }

  @keyframes twinkle-drift {
    0% { transform: translate3d(0, 0, 0); opacity: 0.45; }
    50% { transform: translate3d(0, -10px, 0); opacity: 0.62; }
    100% { transform: translate3d(0, 0, 0); opacity: 0.45; }
  }

  @keyframes shimmer-sweep {
    0% { transform: translateX(-25%); opacity: 0.45; }
    50% { transform: translateX(25%); opacity: 0.85; }
    100% { transform: translateX(-25%); opacity: 0.45; }
  }

  #text {
    position: absolute;
    bottom: 8%;
    width: 100%;
    text-align: center;
    font-size: clamp(18px, 4vw, 28px);
    letter-spacing: 3px;
    color: #ff7aa2;
    text-shadow:
      0 0 10px rgba(255,120,160,0.9),
      0 0 30px rgba(255,80,140,0.7),
      0 0 50px rgba(255,50,120,0.5);
    pointer-events: none;
    z-index: 10;
  }
  
  canvas {
    display: block;
  }
</style>
</head>

<body>
<div id="cardOverlay" class="card-overlay" role="button" aria-label="M·ªü thi·ªáp m·ªùi sinh nh·∫≠t" tabindex="0">
  <div class="card" aria-hidden="false">
    <div class="card-base" aria-hidden="true">
      <div class="card-base-content">
        <div class="card-inside">
          <div class="inside-left">
            <div>
              <div class="card-base-title">Ch√∫c m·ª´ng sinh nh·∫≠t Lan Anh</div>
              <div class="card-base-sub"> 27/01/2026 ‚ú®</div>
            </div>
          </div>
          <div class="inside-right">
            <div>
              <div class="card-base-title">M·ªùi c√°c b·∫°n t·ªõi d·ª± sinh nh·∫≠t v·ªõi m√¨nh nh√©</div>
              <div class="card-base-sub">√Çm nh·∫°c s·∫Ω b·∫Øt ƒë·∫ßu khi b·∫°n m·ªü thi·ªáp üé∂</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card-cover" aria-hidden="true">
      <div class="card-cover-face card-cover-front">
        <div class="cover-content">
          <div class="cover-badge" aria-hidden="true"><span class="badge-dot"></span><span style="opacity:.92">Invitation</span></div>
          <div style="height: 14px"></div>
          <div class="invite-title">Thi·ªáp m·ªùi sinh nh·∫≠t</div>
          <div class="invite-name">Lan Anh</div>
          <div class="invite-hint"><strong>Click / ch·∫°m</strong> ƒë·ªÉ m·ªü </div>
        </div>
      </div>
    </div>
  </div>
</div>

<audio id="bgMusic" src="music.mp3" preload="auto" loop playsinline></audio>

<div id="text">üéÇ Ch√∫c m·ª´ng sinh nh·∫≠t Lan Anh ‚ù§Ô∏è Ch√∫c Lan Anh lu√¥n lu√¥n r·ª±c r·ª° ‚ú®</div>

<script>
(() => {
  const overlay = document.getElementById('cardOverlay');
  const bgMusic = document.getElementById('bgMusic');
  if (!overlay) return;

  // Timing: make the overlay fully disappear ~5s after user opens the card.
  // Total = HIDE_DELAY_MS + OVERLAY_FADE_MS
  const OVERLAY_FADE_MS = 550;
  const HIDE_DELAY_MS = 5000 - OVERLAY_FADE_MS;

  let opened = false;
  let musicStarted = false;
  let experienceStarted = false;

  function startExperience() {
    if (experienceStarted) return;
    experienceStarted = true;
    document.body.classList.add('experience-on');
  }

  function startMusicOnClick() {
    if (musicStarted) return;
    musicStarted = true;

    if (!bgMusic) return;
    bgMusic.volume = 0.35;
    // Some browsers require play() to be directly triggered by a user gesture (we call this from click/Enter).
    const p = bgMusic.play();
    if (p && typeof p.catch === 'function') {
      p.catch(() => {
        // Ignore autoplay restrictions / user didn't interact enough.
      });
    }
  }

  function openCard() {
    if (opened) return;
    opened = true;

    overlay.classList.add('open');
    startMusicOnClick();

    // Fade overlay out after the opening animation finishes.
    window.setTimeout(() => {
      overlay.classList.add('hide');
    }, HIDE_DELAY_MS);

    // Start the experience only after the overlay is fully hidden (fallback timer).
    window.setTimeout(() => {
      startExperience();
    }, HIDE_DELAY_MS + OVERLAY_FADE_MS + 200);
  }

  // Prefer transition end to ensure overlay is fully gone before starting effects.
  overlay.addEventListener('transitionend', (e) => {
    if (e.target !== overlay) return;
    if (e.propertyName !== 'opacity') return;
    if (!overlay.classList.contains('hide')) return;
    startExperience();
  });

  overlay.addEventListener('click', openCard, { passive: true });
  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      openCard();
    }
  });
})();
</script>

<script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
<script>
/* ================= CONFIG ================= */
const CONFIG = {
  heartParticles: 12000,      // Particles cho tim ƒë·∫∑c
  heartScale: 0.9,
  particleSize: 0.7,
  ringParticles: 3000,
  imageUrl: "laanh.jpg",
  imageSize: 13               // K√≠ch th∆∞·ªõc ·∫£nh trong tim
};

/* ================= SCENE SETUP ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

/* ================= HEART GROUP ================= */
const heartGroup = new THREE.Group();
scene.add(heartGroup);

/* ================= CAMERA SETUP ================= */
function updateCamera() {
  const aspect = window.innerWidth / window.innerHeight;
  camera.position.z = aspect < 1 ? 75 / aspect * 0.7 : 60;
  heartGroup.position.y = aspect < 1 ? 8 : 10;
}
updateCamera();

/* ================= TEXTURES ================= */
const discTexture = new THREE.TextureLoader().load(
  "https://threejs.org/examples/textures/sprites/disc.png"
);

// T·∫°o glow texture cho particles ƒë·∫πp h∆°n
const glowCanvas = document.createElement('canvas');
glowCanvas.width = 64;
glowCanvas.height = 64;
const glowCtx = glowCanvas.getContext('2d');
const gradient = glowCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
gradient.addColorStop(0, 'rgba(255,255,255,1)');
gradient.addColorStop(0.2, 'rgba(255,150,180,0.8)');
gradient.addColorStop(0.5, 'rgba(255,100,150,0.3)');
gradient.addColorStop(1, 'rgba(255,50,100,0)');
glowCtx.fillStyle = gradient;
glowCtx.fillRect(0, 0, 64, 64);
const glowTexture = new THREE.CanvasTexture(glowCanvas);

/* ================= HEART MATH ================= */
function heartShape(t, scale = 1) {
  const x = 16 * Math.pow(Math.sin(t), 3);
  const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
  return { x: x * scale, y: y * scale };
}

// Ki·ªÉm tra ƒëi·ªÉm n·∫±m trong tr√°i tim (d√πng parametric heart)
function isInsideHeart(px, py, scale = 1) {
  // Scale v·ªÅ h·ªá t·ªça ƒë·ªô chu·∫©n c·ªßa heart equation
  const x = px / (16 * scale);
  const y = (py + 2 * scale) / (16 * scale); // offset Y v√¨ t√¢m tim kh√¥ng ·ªü 0
  
  // Heart equation: (x¬≤ + y¬≤ - 1)¬≥ - x¬≤y¬≥ ‚â§ 0
  const x2 = x * x;
  const y2 = y * y;
  const eq = Math.pow(x2 + y2 - 1, 3) - x2 * y2 * y;
  return eq <= 0;
}

// T·∫°o filled heart points s·ª≠ d·ª•ng parametric approach
function generateFilledHeartPoints(count, scale) {
  const points = [];
  
  while (points.length < count) {
    // Random g√≥c v√† kho·∫£ng c√°ch t·ª´ t√¢m
    const t = Math.random() * Math.PI * 2;
    const r = Math.random(); // 0-1, s·∫Ω scale theo heart shape
    
    // Heart parametric
    const heartX = 16 * Math.pow(Math.sin(t), 3);
    const heartY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    
    // Fill b√™n trong b·∫±ng c√°ch nh√¢n v·ªõi r
    const x = heartX * r * scale;
    const y = heartY * r * scale;
    const z = (Math.random() - 0.5) * 4 * scale;
    
    points.push(new THREE.Vector3(x, y, z));
  }
  return points;
}

/* ================= HEART PARTICLES ================= */
const HEART_POINTS = generateFilledHeartPoints(CONFIG.heartParticles, CONFIG.heartScale);
const heartPositions = new Float32Array(CONFIG.heartParticles * 3);
const heartColors = new Float32Array(CONFIG.heartParticles * 3);
const heartTargets = [];
const heartSpeeds = [];
const heartArrived = []; // Track xem particle ƒë√£ ƒë·∫øn ƒë√≠ch ch∆∞a
const heartDelays = []; // Delay tr∆∞·ªõc khi reset

for (let i = 0; i < CONFIG.heartParticles; i++) {
  const target = HEART_POINTS[i];
  heartTargets.push(target);
  
  // Spawn t·ª´ d∆∞·ªõi l√™n
  heartPositions[i * 3] = (Math.random() - 0.5) * 80;
  heartPositions[i * 3 + 1] = -50 - Math.random() * 30;
  heartPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
  
  heartSpeeds.push(0.003 + Math.random() * 0.007); // Ch·∫≠m h∆°n, l√£ng m·∫°n h∆°n
  heartArrived.push(false);
  heartDelays.push(0);
  
  // Gradient color: ƒë·ªè h·ªìng ƒë·∫πp
  const normalizedY = (target.y + 15) / 30;
  heartColors[i * 3] = 0.85 + Math.random() * 0.15;
  heartColors[i * 3 + 1] = 0.15 + normalizedY * 0.25 + Math.random() * 0.1;
  heartColors[i * 3 + 2] = 0.35 + normalizedY * 0.2 + Math.random() * 0.15;
}

const heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute('position', new THREE.BufferAttribute(heartPositions, 3));
heartGeo.setAttribute('color', new THREE.BufferAttribute(heartColors, 3));

const heartMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: CONFIG.particleSize,
  vertexColors: true,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const heartMesh = new THREE.Points(heartGeo, heartMat);
heartGroup.add(heartMesh);

/* ================= STREAM PARTICLES (bay v√†o b·ªìi ƒë·∫Øp tim) ================= */
const STREAM_COUNT = 800;
const streamPositions = new Float32Array(STREAM_COUNT * 3);
const streamColors = new Float32Array(STREAM_COUNT * 3);
const streamTargets = [];
const streamSpeeds = [];
const streamPhases = []; // 0: bay l√™n, 1: bay v√†o tim

function resetStreamParticle(i) {
  const idx = i * 3;
  // Spawn t·ª´ v√≤ng ring ph√≠a d∆∞·ªõi
  const angle = Math.random() * Math.PI * 2;
  const radius = 15 + Math.random() * 8;
  
  streamPositions[idx] = Math.cos(angle) * radius;
  streamPositions[idx + 1] = -25 + Math.random() * 5;
  streamPositions[idx + 2] = Math.sin(angle) * radius;
  
  // Target l√† 1 ƒëi·ªÉm tr√™n vi·ªÅn tr√°i tim
  const t = Math.random() * Math.PI * 2;
  const heartX = 16 * Math.pow(Math.sin(t), 3) * CONFIG.heartScale;
  const heartY = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * CONFIG.heartScale;
  
  streamTargets[i] = new THREE.Vector3(heartX, heartY, (Math.random() - 0.5) * 3);
  streamSpeeds[i] = 0.015 + Math.random() * 0.025;
  streamPhases[i] = 0;
}

for (let i = 0; i < STREAM_COUNT; i++) {
  resetStreamParticle(i);
  // Stagger initial positions
  streamPositions[i * 3 + 1] = -25 + Math.random() * 50;
  
  // M√†u h·ªìng s√°ng
  streamColors[i * 3] = 1;
  streamColors[i * 3 + 1] = 0.4 + Math.random() * 0.3;
  streamColors[i * 3 + 2] = 0.6 + Math.random() * 0.2;
}

const streamGeo = new THREE.BufferGeometry();
streamGeo.setAttribute('position', new THREE.BufferAttribute(streamPositions, 3));
streamGeo.setAttribute('color', new THREE.BufferAttribute(streamColors, 3));

const streamMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: 0.6,
  vertexColors: true,
  transparent: true,
  opacity: 0.85,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const streamMesh = new THREE.Points(streamGeo, streamMat);
heartGroup.add(streamMesh);

/* ================= IMAGE WITH HEART MASK ================= */
// T·∫°o canvas ƒë·ªÉ mask ·∫£nh theo h√¨nh tr√°i tim M·ªÄM M·∫†I
const imgElement = new Image();
imgElement.crossOrigin = "anonymous";
imgElement.onload = function() {
  const canvas = document.createElement('canvas');
  const size = 512;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  
  const scale = size / 38;
  const offsetX = size / 2;
  const offsetY = size / 2 + 3 * scale;
  
  // H√†m v·∫Ω ƒë∆∞·ªùng tr√°i tim
  function drawHeartPath(ctx, scale, offsetX, offsetY) {
    ctx.beginPath();
    for (let t = 0; t <= Math.PI * 2; t += 0.01) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
      const px = offsetX + x * scale;
      const py = offsetY + y * scale;
      if (t === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
  }
  
  // T·∫°o mask m·ªÅm m·∫°i b·∫±ng c√°ch v·∫Ω nhi·ªÅu l·ªõp v·ªõi ƒë·ªô m·ªù gi·∫£m d·∫ßn
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = size;
  tempCanvas.height = size;
  const tempCtx = tempCanvas.getContext('2d');
  
  // V·∫Ω ·∫£nh tr∆∞·ªõc
  const heartWidth = 32 * scale;
  const heartHeight = 30 * scale;
  const imgW = heartWidth * 0.95;
  const imgH = heartHeight * 1.1;
  const imgX = (size - imgW) / 2;
  const imgY = offsetY - heartHeight * 0.35;
  tempCtx.drawImage(imgElement, imgX, imgY, imgW, imgH);
  
  // T·∫°o mask gradient m·ªÅm
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = size;
  maskCanvas.height = size;
  const maskCtx = maskCanvas.getContext('2d');
  
  // V·∫Ω tr√°i tim v·ªõi blur effect b·∫±ng shadow
  maskCtx.shadowColor = 'white';
  maskCtx.shadowBlur = 15; // ƒê·ªô m·ªÅm vi·ªÅn
  maskCtx.shadowOffsetX = 0;
  maskCtx.shadowOffsetY = 0;
  maskCtx.fillStyle = 'white';
  drawHeartPath(maskCtx, scale * 0.92, offsetX, offsetY); // Nh·ªè h∆°n m·ªôt ch√∫t
  maskCtx.fill();
  
  // V·∫Ω l·∫°i kh√¥ng shadow ƒë·ªÉ c√≥ core r√µ
  maskCtx.shadowBlur = 0;
  drawHeartPath(maskCtx, scale * 0.88, offsetX, offsetY);
  maskCtx.fill();
  
  // Apply mask l√™n ·∫£nh
  ctx.drawImage(tempCanvas, 0, 0);
  ctx.globalCompositeOperation = 'destination-in';
  ctx.drawImage(maskCanvas, 0, 0);
  
  // T·∫°o texture t·ª´ canvas
  const maskedTexture = new THREE.CanvasTexture(canvas);
  maskedTexture.needsUpdate = true;
  
  const imageMat = new THREE.SpriteMaterial({
    map: maskedTexture,
    transparent: true,
    opacity: 0,
    blending: THREE.NormalBlending,
    depthTest: false
  });
  
  const imageSprite = new THREE.Sprite(imageMat);
  imageSprite.scale.set(CONFIG.imageSize, CONFIG.imageSize, 1);
  imageSprite.position.set(0, -0.5, 1.5);
  imageSprite.renderOrder = 999;
  heartGroup.add(imageSprite);
  
  // L∆∞u reference ƒë·ªÉ animate
  window.imageSprite = imageSprite;
  window.imageMat = imageMat;
};
imgElement.src = CONFIG.imageUrl;

// Fade in ·∫£nh sau khi particles t·ª• l·∫°i
let imageOpacity = 0;
let imageReady = false;

// Start this timer only when the experience actually starts.
(function scheduleImageReady() {
  if (document.body.classList.contains('experience-on')) {
    setTimeout(() => { imageReady = true; }, 5000); // 5 gi√¢y - ch·ªù tim h√¨nh th√†nh ƒë·∫πp
  } else {
    setTimeout(scheduleImageReady, 200);
  }
})();

/* ================= ENERGY RING ================= */
const ringPositions = new Float32Array(CONFIG.ringParticles * 3);
const ringColors = new Float32Array(CONFIG.ringParticles * 3);

for (let i = 0; i < CONFIG.ringParticles; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 18 + Math.random() * 4;
  
  ringPositions[i * 3] = Math.cos(angle) * radius;
  ringPositions[i * 3 + 1] = -22 + (Math.random() - 0.5) * 2;
  ringPositions[i * 3 + 2] = Math.sin(angle) * radius;
  
  // Cyan gradient
  ringColors[i * 3] = 0.1 + Math.random() * 0.2;
  ringColors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
  ringColors[i * 3 + 2] = 1;
}

const ringGeo = new THREE.BufferGeometry();
ringGeo.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));
ringGeo.setAttribute('color', new THREE.BufferAttribute(ringColors, 3));

const ringMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: 0.8,
  vertexColors: true,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const ringMesh = new THREE.Points(ringGeo, ringMat);
heartGroup.add(ringMesh);

/* ================= FLOATING PARTICLES ================= */
const FLOAT_COUNT = 2000;
const floatPositions = new Float32Array(FLOAT_COUNT * 3);
const floatSpeeds = [];

for (let i = 0; i < FLOAT_COUNT; i++) {
  floatPositions[i * 3] = (Math.random() - 0.5) * 60;
  floatPositions[i * 3 + 1] = -35 + Math.random() * 70;
  floatPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
  floatSpeeds.push(0.03 + Math.random() * 0.08);
}

const floatGeo = new THREE.BufferGeometry();
floatGeo.setAttribute('position', new THREE.BufferAttribute(floatPositions, 3));

const floatMat = new THREE.PointsMaterial({
  map: discTexture,
  color: 0xff5080,
  size: 0.5,
  transparent: true,
  opacity: 0.5,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const floatMesh = new THREE.Points(floatGeo, floatMat);
heartGroup.add(floatMesh);

/* ================= üéÑ CHRISTMAS EFFECTS üéÑ ================= */

// ‚ùÑÔ∏è SNOW PARTICLES
const SNOW_COUNT = 500;
const snowPositions = new Float32Array(SNOW_COUNT * 3);
const snowSpeeds = [];
const snowDrifts = [];

for (let i = 0; i < SNOW_COUNT; i++) {
  snowPositions[i * 3] = (Math.random() - 0.5) * 100;
  snowPositions[i * 3 + 1] = Math.random() * 80 - 20;
  snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
  snowSpeeds.push(0.02 + Math.random() * 0.05);
  snowDrifts.push(Math.random() * Math.PI * 2); // Phase for swaying
}

const snowGeo = new THREE.BufferGeometry();
snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));

// T·∫°o snowflake texture
const snowCanvas = document.createElement('canvas');
snowCanvas.width = 32;
snowCanvas.height = 32;
const snowCtx = snowCanvas.getContext('2d');
const snowGrad = snowCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
snowGrad.addColorStop(0, 'rgba(255,255,255,1)');
snowGrad.addColorStop(0.3, 'rgba(255,255,255,0.8)');
snowGrad.addColorStop(1, 'rgba(255,255,255,0)');
snowCtx.fillStyle = snowGrad;
snowCtx.fillRect(0, 0, 32, 32);
const snowTexture = new THREE.CanvasTexture(snowCanvas);

const snowMat = new THREE.PointsMaterial({
  map: snowTexture,
  size: 0.8,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const snowMesh = new THREE.Points(snowGeo, snowMat);
scene.add(snowMesh); // Add to scene, not heartGroup

// üéÖ SANTA HAT (b·∫±ng particles)
const HAT_PARTICLES = 600;
const hatPositions = new Float32Array(HAT_PARTICLES * 3);
const hatColors = new Float32Array(HAT_PARTICLES * 3);

// V·ªã tr√≠ m≈© tr√™n ƒë·ªânh tim
const hatBaseY = 13 * CONFIG.heartScale; // ƒê·ªânh tim
const hatOffsetX = 5; // Nghi√™ng sang ph·∫£i m·ªôt ch√∫t

for (let i = 0; i < HAT_PARTICLES; i++) {
  let x, y, z;
  const part = Math.random();
  
  if (part < 0.6) {
    // Ph·∫ßn th√¢n m≈© ƒë·ªè (h√¨nh tam gi√°c/cone)
    const height = Math.random();
    const radius = (1 - height) * 6; // Nh·ªè d·∫ßn l√™n ƒë·ªânh
    const angle = Math.random() * Math.PI * 2;
    
    x = hatOffsetX + Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
    y = hatBaseY + height * 12;
    z = Math.sin(angle) * radius * 0.5 + (Math.random() - 0.5) * 2;
    
    // M√†u ƒë·ªè
    hatColors[i * 3] = 0.9 + Math.random() * 0.1;
    hatColors[i * 3 + 1] = 0.1 + Math.random() * 0.1;
    hatColors[i * 3 + 2] = 0.1 + Math.random() * 0.1;
  } 
  else if (part < 0.85) {
    // Vi·ªÅn tr·∫Øng d∆∞·ªõi m≈©
    const angle = Math.random() * Math.PI * 2;
    const radius = 6 + Math.random() * 1.5;
    
    x = hatOffsetX + Math.cos(angle) * radius;
    y = hatBaseY + Math.random() * 2;
    z = Math.sin(angle) * radius * 0.5;
    
    // M√†u tr·∫Øng
    hatColors[i * 3] = 1;
    hatColors[i * 3 + 1] = 1;
    hatColors[i * 3 + 2] = 1;
  }
  else {
    // Qu·∫£ c·∫ßu tr·∫Øng tr√™n ƒë·ªânh
    const angle = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const radius = 1.5 + Math.random() * 0.5;
    
    x = hatOffsetX + 2 + Math.sin(phi) * Math.cos(angle) * radius;
    y = hatBaseY + 13 + Math.sin(phi) * Math.sin(angle) * radius;
    z = Math.cos(phi) * radius;
    
    // M√†u tr·∫Øng s√°ng
    hatColors[i * 3] = 1;
    hatColors[i * 3 + 1] = 1;
    hatColors[i * 3 + 2] = 1;
  }
  
  hatPositions[i * 3] = x;
  hatPositions[i * 3 + 1] = y;
  hatPositions[i * 3 + 2] = z;
}

const hatGeo = new THREE.BufferGeometry();
hatGeo.setAttribute('position', new THREE.BufferAttribute(hatPositions, 3));
hatGeo.setAttribute('color', new THREE.BufferAttribute(hatColors, 3));

const hatMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: 0.7,
  vertexColors: true,
  transparent: true,
  opacity: 0.95,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const hatMesh = new THREE.Points(hatGeo, hatMat);
heartGroup.add(hatMesh);

/* ================= üéÖü¶å SANTA SLEIGH FLYING ================= */
const sleighGroup = new THREE.Group();
scene.add(sleighGroup);

// T·∫°o Santa + Sleigh + Reindeers b·∫±ng particles - TƒÇNG S·ªê L∆Ø·ª¢NG
const SLEIGH_PARTICLES = 1200;
const sleighPositions = new Float32Array(SLEIGH_PARTICLES * 3);
const sleighColors = new Float32Array(SLEIGH_PARTICLES * 3);

for (let i = 0; i < SLEIGH_PARTICLES; i++) {
  let x, y, z;
  let r, g, b;
  const part = Math.random();
  
  if (part < 0.15) {
    // ü¶å Tu·∫ßn l·ªôc 1 - TH√ÇN (ph√≠a tr∆∞·ªõc b√™n tr√°i)
    const bx = -10;
    const bz = -0.5;
    x = bx + (Math.random() - 0.5) * 3;
    y = (Math.random() - 0.5) * 2;
    z = bz + (Math.random() - 0.5) * 1.5;
    // M√†u n√¢u s√°ng
    r = 0.7 + Math.random() * 0.2;
    g = 0.4 + Math.random() * 0.15;
    b = 0.2 + Math.random() * 0.1;
  }
  else if (part < 0.2) {
    // ü¶å Tu·∫ßn l·ªôc 1 - CH√ÇN
    const bx = -10;
    const bz = -0.5;
    const legX = (Math.random() > 0.5 ? 0.8 : -0.8);
    x = bx + legX + (Math.random() - 0.5) * 0.5;
    y = -1.5 + Math.random() * 1.5;
    z = bz + (Math.random() - 0.5) * 0.3;
    r = 0.6; g = 0.35; b = 0.15;
  }
  else if (part < 0.22) {
    // ü¶å Tu·∫ßn l·ªôc 1 - S·ª™NG
    const bx = -11;
    const bz = -0.5;
    const antler = Math.random();
    x = bx + (Math.random() - 0.5) * 0.8;
    y = 1.5 + antler * 1.5;
    z = bz + (antler > 0.5 ? 0.5 : -0.5) + (Math.random() - 0.5) * 0.3;
    r = 0.5; g = 0.3; b = 0.15;
  }
  else if (part < 0.37) {
    // ü¶å Tu·∫ßn l·ªôc 2 - TH√ÇN (ph√≠a tr∆∞·ªõc b√™n ph·∫£i)
    const bx = -10;
    const bz = 2.5;
    x = bx + (Math.random() - 0.5) * 3;
    y = (Math.random() - 0.5) * 2;
    z = bz + (Math.random() - 0.5) * 1.5;
    r = 0.7 + Math.random() * 0.2;
    g = 0.4 + Math.random() * 0.15;
    b = 0.2 + Math.random() * 0.1;
  }
  else if (part < 0.42) {
    // ü¶å Tu·∫ßn l·ªôc 2 - CH√ÇN
    const bx = -10;
    const bz = 2.5;
    const legX = (Math.random() > 0.5 ? 0.8 : -0.8);
    x = bx + legX + (Math.random() - 0.5) * 0.5;
    y = -1.5 + Math.random() * 1.5;
    z = bz + (Math.random() - 0.5) * 0.3;
    r = 0.6; g = 0.35; b = 0.15;
  }
  else if (part < 0.44) {
    // ü¶å Tu·∫ßn l·ªôc 2 - S·ª™NG  
    const bx = -11;
    const bz = 2.5;
    const antler = Math.random();
    x = bx + (Math.random() - 0.5) * 0.8;
    y = 1.5 + antler * 1.5;
    z = bz + (antler > 0.5 ? 0.5 : -0.5) + (Math.random() - 0.5) * 0.3;
    r = 0.5; g = 0.3; b = 0.15;
  }
  else if (part < 0.47) {
    // üëÉ M≈©i ƒë·ªè Rudolph (tu·∫ßn l·ªôc 1)
    x = -11.8 + (Math.random() - 0.5) * 0.4;
    y = 0.3 + (Math.random() - 0.5) * 0.4;
    z = -0.5 + (Math.random() - 0.5) * 0.3;
    // M√†u ƒë·ªè ph√°t s√°ng
    r = 1;
    g = 0.1 + Math.random() * 0.2;
    b = 0.1;
  }
  else if (part < 0.65) {
    // üõ∑ Xe tr∆∞·ª£t tuy·∫øt - TH√ÇN XE
    x = (Math.random() - 0.5) * 6;
    y = -1.2 + (Math.random() - 0.5) * 1.5;
    z = 1 + (Math.random() - 0.5) * 3;
    // M√†u ƒë·ªè ƒë·∫≠m
    r = 0.85 + Math.random() * 0.15;
    g = 0.08;
    b = 0.08;
  }
  else if (part < 0.7) {
    // üõ∑ Xe - THANH TR∆Ø·ª¢T D∆Ø·ªöI
    const side = Math.random() > 0.5 ? -0.8 : 2.8;
    x = -2 + Math.random() * 6;
    y = -2.5 + (Math.random() - 0.5) * 0.4;
    z = side + (Math.random() - 0.5) * 0.3;
    // M√†u v√†ng kim
    r = 0.9; g = 0.75; b = 0.3;
  }
  else if (part < 0.88) {
    // üéÖ √îng gi√† Noel - TH√ÇN
    x = 1.5 + (Math.random() - 0.5) * 2.5;
    y = 0.5 + Math.random() * 2.5;
    z = 1 + (Math.random() - 0.5) * 2;
    
    const santaPart = Math.random();
    if (santaPart < 0.5) {
      // √Åo ƒë·ªè
      r = 1; g = 0.1; b = 0.1;
    } else if (santaPart < 0.7) {
      // Vi·ªÅn tr·∫Øng √°o
      r = 1; g = 1; b = 1;
    } else {
      // Th·∫Øt l∆∞ng ƒëen
      r = 0.15; g = 0.15; b = 0.15;
    }
  }
  else if (part < 0.92) {
    // üéÖ √îng gi√† Noel - ƒê·∫¶U + M≈®
    x = 1.5 + (Math.random() - 0.5) * 1.2;
    y = 3 + Math.random() * 1.8;
    z = 1 + (Math.random() - 0.5) * 1;
    
    const headPart = Math.random();
    if (headPart < 0.3) {
      // M·∫∑t
      r = 1; g = 0.85; b = 0.75;
    } else if (headPart < 0.5) {
      // R√¢u tr·∫Øng
      r = 1; g = 1; b = 1;
    } else {
      // M≈© ƒë·ªè
      r = 1; g = 0.1; b = 0.1;
    }
  }
  else if (part < 0.95) {
    // üéÅ T√∫i qu√† ph√≠a sau
    x = 3.5 + (Math.random() - 0.5) * 2;
    y = 0 + Math.random() * 2;
    z = 1 + (Math.random() - 0.5) * 2;
    // M√†u n√¢u ƒë·ªè
    r = 0.6 + Math.random() * 0.2;
    g = 0.25;
    b = 0.15;
  }
  else {
    // ‚ú® D√¢y c∆∞∆°ng v√†ng
    const t = Math.random();
    x = -8 + t * 9;
    y = -0.3 + Math.sin(t * Math.PI * 0.8) * 0.8;
    z = 1 + (Math.random() - 0.5) * 0.8;
    // M√†u v√†ng l·∫•p l√°nh
    r = 1;
    g = 0.85 + Math.random() * 0.15;
    b = 0.2 + Math.random() * 0.2;
  }
  
  sleighPositions[i * 3] = x;
  sleighPositions[i * 3 + 1] = y;
  sleighPositions[i * 3 + 2] = z;
  
  sleighColors[i * 3] = r;
  sleighColors[i * 3 + 1] = g;
  sleighColors[i * 3 + 2] = b;
}

const sleighGeo = new THREE.BufferGeometry();
sleighGeo.setAttribute('position', new THREE.BufferAttribute(sleighPositions, 3));
sleighGeo.setAttribute('color', new THREE.BufferAttribute(sleighColors, 3));

const sleighMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: 0.8,  // TƒÉng size ƒë·ªÉ r√µ h∆°n
  vertexColors: true,
  transparent: true,
  opacity: 1.0,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const sleighMesh = new THREE.Points(sleighGeo, sleighMat);
sleighGroup.add(sleighMesh);

// Trail particles (v·ªát s√°ng ph√≠a sau) - TƒÇNG S·ªê L∆Ø·ª¢NG
const TRAIL_COUNT = 200;
const trailPositions = new Float32Array(TRAIL_COUNT * 3);
const trailColors = new Float32Array(TRAIL_COUNT * 3);

for (let i = 0; i < TRAIL_COUNT; i++) {
  trailPositions[i * 3] = 3 + i * 0.3;
  trailPositions[i * 3 + 1] = (Math.random() - 0.5) * 1;
  trailPositions[i * 3 + 2] = 1 + (Math.random() - 0.5) * 1;
  
  const fade = 1 - i / TRAIL_COUNT;
  trailColors[i * 3] = 1;
  trailColors[i * 3 + 1] = 0.8 * fade;
  trailColors[i * 3 + 2] = 0.3 * fade;
}

const trailGeo = new THREE.BufferGeometry();
trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

const trailMat = new THREE.PointsMaterial({
  map: glowTexture,
  size: 0.4,
  vertexColors: true,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const trailMesh = new THREE.Points(trailGeo, trailMat);
sleighGroup.add(trailMesh);

// Trailing banner text (like the sleigh is pulling it)
const bannerCanvas = document.createElement('canvas');
bannerCanvas.width = 1024;
bannerCanvas.height = 256;
const bannerCtx = bannerCanvas.getContext('2d');

function roundRect(ctx, x, y, w, h, r) {
  const radius = Math.min(r, w / 2, h / 2);
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + w, y, x + w, y + h, radius);
  ctx.arcTo(x + w, y + h, x, y + h, radius);
  ctx.arcTo(x, y + h, x, y, radius);
  ctx.arcTo(x, y, x + w, y, radius);
  ctx.closePath();
}

function drawBannerText() {
  const ctx = bannerCtx;
  ctx.clearRect(0, 0, bannerCanvas.width, bannerCanvas.height);

  // Soft glow background
  ctx.save();
  ctx.globalAlpha = 0.9;
  const bgGrad = ctx.createLinearGradient(0, 0, bannerCanvas.width, bannerCanvas.height);
  bgGrad.addColorStop(0, 'rgba(255,120,190,0.20)');
  bgGrad.addColorStop(0.55, 'rgba(160,120,255,0.16)');
  bgGrad.addColorStop(1, 'rgba(110,220,255,0.10)');
  ctx.fillStyle = bgGrad;
  roundRect(ctx, 40, 46, bannerCanvas.width - 80, bannerCanvas.height - 92, 54);
  ctx.fill();

  // Inner glass
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = 'rgba(10, 6, 18, 0.45)';
  roundRect(ctx, 52, 58, bannerCanvas.width - 104, bannerCanvas.height - 116, 44);
  ctx.fill();

  // Border
  ctx.globalAlpha = 0.9;
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(255,255,255,0.28)';
  roundRect(ctx, 52, 58, bannerCanvas.width - 104, bannerCanvas.height - 116, 44);
  ctx.stroke();

  // Sparkles
  ctx.globalAlpha = 0.55;
  for (let i = 0; i < 120; i++) {
    const x = 80 + Math.random() * (bannerCanvas.width - 160);
    const y = 70 + Math.random() * (bannerCanvas.height - 140);
    const s = 1 + Math.random() * 2.2;
    ctx.fillStyle = `rgba(255,255,255,${0.12 + Math.random() * 0.35})`;
    ctx.beginPath();
    ctx.arc(x, y, s, 0, Math.PI * 2);
    ctx.fill();
  }

  // Text
  ctx.globalAlpha = 1;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.font = '800 54px Poppins, Arial, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 16;
  ctx.shadowOffsetY = 8;
  ctx.fillText('Ch√∫c m·ª´ng sinh nh·∫≠t', bannerCanvas.width / 2, 108);

  ctx.shadowBlur = 0;
  ctx.font = '400 64px "Great Vibes", cursive';
  const nameGrad = ctx.createLinearGradient(260, 0, bannerCanvas.width - 260, 0);
  nameGrad.addColorStop(0, 'rgba(255,240,248,0.98)');
  nameGrad.addColorStop(0.5, 'rgba(255,180,222,0.98)');
  nameGrad.addColorStop(1, 'rgba(200,190,255,0.98)');
  ctx.fillStyle = nameGrad;
  ctx.fillText('Lan Anh', bannerCanvas.width / 2, 168);

  ctx.restore();
}

drawBannerText();
const bannerTexture = new THREE.CanvasTexture(bannerCanvas);
bannerTexture.needsUpdate = true;
bannerTexture.minFilter = THREE.LinearFilter;
bannerTexture.magFilter = THREE.LinearFilter;

const bannerMat = new THREE.SpriteMaterial({
  map: bannerTexture,
  transparent: true,
  opacity: 0.98,
  depthTest: false,
  depthWrite: false
});

const bannerSprite = new THREE.Sprite(bannerMat);
bannerSprite.scale.set(28, 7, 1);
bannerSprite.position.set(18, 2.6, 1.0);
bannerSprite.renderOrder = 2000;
sleighGroup.add(bannerSprite);

// Sleigh orbit parameters
const SLEIGH_RADIUS = 35;
const SLEIGH_HEIGHT = 15;
const SLEIGH_SPEED = 0.3;

/* ================= ANIMATE ================= */
function animate() {
  requestAnimationFrame(animate);

  // Do not advance effects until the card overlay has fully disappeared.
  if (!document.body.classList.contains('experience-on')) return;
  
  const time = Date.now() * 0.001;
  
  // Animate heart particles
  const hPos = heartGeo.attributes.position.array;
  for (let i = 0; i < CONFIG.heartParticles; i++) {
    const idx = i * 3;
    const target = heartTargets[i];
    const speed = heartSpeeds[i];
    
    hPos[idx] += (target.x - hPos[idx]) * speed;
    hPos[idx + 1] += (target.y - hPos[idx + 1]) * speed;
    hPos[idx + 2] += (target.z - hPos[idx + 2]) * speed;
  }
  heartGeo.attributes.position.needsUpdate = true;
  
  // Animate STREAM particles (bay v√†o b·ªìi ƒë·∫Øp tim)
  const sPos = streamGeo.attributes.position.array;
  for (let i = 0; i < STREAM_COUNT; i++) {
    const idx = i * 3;
    const target = streamTargets[i];
    const speed = streamSpeeds[i];
    
    // Bay v·ªÅ ph√≠a target
    sPos[idx] += (target.x - sPos[idx]) * speed;
    sPos[idx + 1] += (target.y - sPos[idx + 1]) * speed;
    sPos[idx + 2] += (target.z - sPos[idx + 2]) * speed;
    
    // Ki·ªÉm tra ƒë√£ ƒë·∫øn g·∫ßn target ch∆∞a
    const dx = target.x - sPos[idx];
    const dy = target.y - sPos[idx + 1];
    const dz = target.z - sPos[idx + 2];
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    if (dist < 1) {
      // ƒê√£ ƒë·∫øn - reset particle
      resetStreamParticle(i);
    }
  }
  streamGeo.attributes.position.needsUpdate = true;
  
  // Pulse nh·∫π
  const pulse = 1 + Math.sin(time * 2) * 0.02;
  heartMesh.scale.set(pulse, pulse, pulse);
  
  // Xoay nh·∫π
  heartMesh.rotation.y = Math.sin(time * 0.3) * 0.1;
  
  // Ring xoay
  ringMesh.rotation.y += 0.01;
  
  // üéÖü¶å Santa Sleigh bay v√≤ng v√≤ng quanh tim
  const sleighAngle = time * SLEIGH_SPEED;
  const sleighX = Math.cos(sleighAngle) * SLEIGH_RADIUS;
  const sleighZ = Math.sin(sleighAngle) * SLEIGH_RADIUS;
  const sleighY = SLEIGH_HEIGHT + Math.sin(time * 0.8) * 3; // Bay l√™n xu·ªëng nh·∫π
  
  sleighGroup.position.set(sleighX, sleighY, sleighZ);
  sleighGroup.rotation.y = -sleighAngle + Math.PI / 2; // H∆∞·ªõng theo ƒë∆∞·ªùng bay
  
  // Tu·∫ßn l·ªôc ch·∫°y (nh·∫•p nh√¥)
  sleighMesh.position.y = Math.sin(time * 8) * 0.15;

  // Banner wobble so it feels like it's being pulled
  if (bannerSprite) {
    bannerSprite.position.y = 2.6 + Math.sin(time * 3.2) * 0.22;
    bannerSprite.material.opacity = 0.92 + Math.sin(time * 2.1) * 0.06;
  }
  
  // Floating particles bay l√™n
  const fPos = floatGeo.attributes.position.array;
  for (let i = 0; i < FLOAT_COUNT; i++) {
    fPos[i * 3 + 1] += floatSpeeds[i];
    if (fPos[i * 3 + 1] > 40) {
      fPos[i * 3 + 1] = -35;
      fPos[i * 3] = (Math.random() - 0.5) * 60;
      fPos[i * 3 + 2] = (Math.random() - 0.5) * 60;
    }
  }
  floatGeo.attributes.position.needsUpdate = true;
  
  // ‚ùÑÔ∏è SNOW FALLING
  const snPos = snowGeo.attributes.position.array;
  for (let i = 0; i < SNOW_COUNT; i++) {
    const idx = i * 3;
    // R∆°i xu·ªëng
    snPos[idx + 1] -= snowSpeeds[i];
    // L·∫Øc l∆∞ theo gi√≥
    snPos[idx] += Math.sin(time * 2 + snowDrifts[i]) * 0.02;
    snPos[idx + 2] += Math.cos(time * 1.5 + snowDrifts[i]) * 0.015;
    
    // Reset khi r∆°i qu√° th·∫•p
    if (snPos[idx + 1] < -30) {
      snPos[idx] = (Math.random() - 0.5) * 100;
      snPos[idx + 1] = 50 + Math.random() * 20;
      snPos[idx + 2] = (Math.random() - 0.5) * 100;
    }
  }
  snowGeo.attributes.position.needsUpdate = true;
  
  // üéÖ Santa hat nh·∫•p nh√¥ nh·∫π theo nh·ªãp tim
  hatMesh.position.y = Math.sin(time * 2) * 0.3;
  hatMesh.rotation.z = Math.sin(time * 0.5) * 0.05; // Nghi√™ng nh·∫π
  
  // Fade in ·∫£nh t·ª´ t·ª´ (d√πng window reference)
  if (imageReady && window.imageMat && imageOpacity < 1) {
    imageOpacity += 0.003; // Fade ch·∫≠m h∆°n, l√£ng m·∫°n h∆°n
    window.imageMat.opacity = Math.min(imageOpacity, 1);
  }
  
  // Image pulse theo tim
  if (window.imageSprite) {
    window.imageSprite.scale.set(
      CONFIG.imageSize * pulse,
      CONFIG.imageSize * pulse,
      1
    );
  }
  
  renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateCamera();
});
</script>
</body>
</html>
